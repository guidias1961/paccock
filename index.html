<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Pac-cock - Peacock Pac-Man Clone</title>
<meta name="description" content="Responsive Pac-Man style game. Play as a pixel peacock chased by ghosts. Single file." />
<style>
  :root{
    --bg:#0b0f14; --panel:#121826; --ink:#eaf2ff; --muted:#9aa4ad;
    --brand:#25a4ff; --ok:#7cffb2; --gold:#ffd166;
    --wall:#132545; --wall-edge:#2d4d87; --floor:#071324; --gate:#20385e;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;
    margin:0;
    background:linear-gradient(-45deg,#8B5CF6,#00C2FF,#FF2A6D,#00FFD1);
    background-size:400% 400%;
    animation:pulseGradient 12s ease infinite;
    color:var(--ink);
    font:14px/1.4 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    overflow-x:hidden;
    position:relative;
    overscroll-behavior:none;
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  @keyframes pulseGradient {
    0%{background-position:0% 50%}
    50%{background-position:100% 50%}
    100%{background-position:0% 50%}
  }

  body::before{
    content:"";
    position:fixed;
    inset:0;
    background-image:linear-gradient(135deg,rgba(255,255,255,0.08) 1px,transparent 1px);
    background-size:40px 40px;
    animation:pulseLines 3s infinite;
    pointer-events:none;
  }
  @keyframes pulseLines{ 0%,100%{opacity:0.3} 50%{opacity:0.6} }

  .wrap{max-width:1100px;margin:0 auto;padding:10px}
  header{display:flex;align-items:center;justify-content:space-between;gap:10px;background:linear-gradient(180deg,#101623,#0e1420);border:1px solid #1c263a;border-radius:12px;padding:8px 10px}
  .brand{display:flex;align-items:center;gap:10px}
  .dot{width:10px;height:10px;border-radius:50%;background:var(--brand);box-shadow:0 0 18px var(--brand)}
  h1{font-size:16px;margin:0}
  .sub{font-size:12px;color:var(--muted)}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .btn{border:1px solid #25324a;background:#0e1523;color:var(--ink);padding:6px 10px;border-radius:10px;font-weight:600;text-decoration:none}
  .btn:hover{filter:brightness(1.1)}
  .btn.tw{border-color:#1c8cd6}
  .btn.buy{border-color:#33d17a}
  .hud{margin-top:8px;display:flex;align-items:center;justify-content:space-between;gap:10px;background:var(--panel);border:1px solid #1c263a;border-radius:12px;padding:8px 10px}
  .row{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .pill{background:#0d1422;border:1px solid #213054;border-radius:999px;padding:4px 10px;min-width:80px;text-align:center}

  #gameShell{
    margin-top:8px;
    background:#0a0f1a;
    border:1px solid #1c263a;
    border-radius:12px;
    position:relative;
    overflow:hidden;
    width:100%;
    max-width:800px;
    margin-left:auto;
    margin-right:auto;
    touch-action:none; /* evita gestos que deslocam a p√°gina no mobile */
  }

  canvas{
    display:block;
    width:100%;
    height:auto;
    aspect-ratio:28/31;
    max-height:calc(100dvh - 220px);
    touch-action:none;
  }

  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(8,12,20,.55),rgba(8,12,20,.75));backdrop-filter:blur(2px)}
  .card{background:#0e1524;border:1px solid #203152;border-radius:14px;padding:16px 14px;max-width:520px;text-align:center}
  .title{font-size:18px;font-weight:800;margin:0 0 6px}
  .desc{color:var(--muted);font-size:13px;margin:0 0 10px}
  .keys{display:flex;gap:6px;justify-content:center;flex-wrap:wrap;margin:6px 0}
  .key{border:1px solid #2b3b5a;background:#0b1220;border-radius:8px;padding:4px 8px;color:#bcd0ee}
  .lives{display:flex;gap:6px;align-items:center}
  .life{width:16px;height:12px;border-radius:50% 50% 40% 40%/60% 60% 40% 40%;background:#07c3ff;box-shadow:0 0 10px #07c3ff}

  .touch{
    position:absolute;
    right:8px;
    bottom: max(8px, env(safe-area-inset-bottom, 8px));
    display:grid; gap:6px;
    grid-template-areas:"up" "left" "down" "right";
    opacity:.95; user-select:none;
  }
  .touch button{
    border:1px solid #2b3b5a;background:#0d1526;color:#cfe1ff;border-radius:10px;
    width:56px;height:44px;font-weight:700;
    touch-action:manipulation; -webkit-tap-highlight-color:transparent;
  }
  @media(min-width:640px){
    .touch{grid-template-areas:"up up" "left right" "down down"; right:10px}
    .touch button{width:64px;height:52px}
  }
  @media(max-width:420px){
    .btn{padding:6px 8px}
    .touch button{width:64px;height:56px}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="dot" aria-hidden="true"></div>
      <div>
        <h1>Pac-Cock</h1>
        <div class="sub">Play as the Peacock. Eat pellets. Dodge ghosts.</div>
      </div>
    </div>
    <div class="actions">
      <a class="btn tw" href="https://x.com/PacCock" target="_blank" rel="noopener">üê¶ Twitter</a>
      <a class="btn buy" href="https://pump.tires" target="_blank" rel="noopener">üõí Buy</a>
    </div>
  </header>

  <div class="hud">
    <div class="row">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">High: <span id="hi">0</span></div>
      <div class="pill">Level: <span id="level">1</span></div>
    </div>
    <div class="row"><div class="lives" id="lives"></div></div>
  </div>

  <div id="gameShell">
    <canvas id="game" width="672" height="744" aria-label="Pac Cock game area"></canvas>

    <div class="overlay" id="overlay">
      <div class="card">
        <div class="title">Tap or press Space to start</div>
        <p class="desc">Arrow keys or WASD to move. On mobile use the buttons. Power orbs let you chomp ghosts briefly.</p>
        <div class="keys"><span class="key">‚Üê</span><span class="key">‚Üí</span><span class="key">‚Üë</span><span class="key">‚Üì</span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></div>
      </div>
    </div>

    <div class="touch" id="touch" aria-label="Touch controls">
      <button class="up"    style="grid-area:up">‚Üë</button>
      <button class="left"  style="grid-area:left">‚Üê</button>
      <button class="down"  style="grid-area:down">‚Üì</button>
      <button class="right" style="grid-area:right">‚Üí</button>
    </div>
  </div>
</div>

<script>
(()=> {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const shell = document.getElementById('gameShell');

  const COLS = 28, ROWS = 31;
  let tile = 24;

  let score = 0, hi = 0, level = 1, pelletsLeft = 0;
  let running = false;

  const DIR = {LEFT:{x:-1,y:0}, RIGHT:{x:1,y:0}, UP:{x:0,y:-1}, DOWN:{x:0,y:1}, NONE:{x:0,y:0}};
  const DIRS_ORDER = [DIR.UP, DIR.LEFT, DIR.DOWN, DIR.RIGHT];
  const isOpposite = (a,b)=> (a.x+b.x===0 && a.y+b.y===0);
  const sameDir = (a,b)=> a&&b&&a.x===b.x&&a.y===b.y;

  const T = {EMPTY:0, WALL:1, PELLET:2, POWER:3, GATE:4, HOUSE:5};

  const grid = Array.from({length:ROWS}, () => Array(COLS).fill(T.PELLET));
  const midY = Math.floor(ROWS/2);
  const midX = Math.floor(COLS/2);

  function carve(){
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) grid[y][x]=T.EMPTY;
    for(let x=0;x<COLS;x++){ grid[0][x]=T.WALL; grid[ROWS-1][x]=T.WALL; }
    for(let y=0;y<ROWS;y++){ grid[y][0]=T.WALL; grid[y][COLS-1]=T.WALL; }
    for(let x=2; x<=5; x++) grid[2][x] = T.WALL;
    for(let x=7; x<=10; x++) grid[2][x] = T.WALL;
    for(let x=12; x<=15; x++) grid[2][x] = T.WALL;
    for(let x=17; x<=20; x++) grid[2][x] = T.WALL;
    for(let x=22; x<=25; x++) grid[2][x] = T.WALL;
    grid[3][2] = T.WALL; grid[3][5] = T.WALL;
    grid[3][7] = T.WALL; grid[3][10] = T.WALL;
    grid[3][12] = T.WALL; grid[3][15] = T.WALL;
    grid[3][17] = T.WALL; grid[3][20] = T.WALL;
    grid[3][22] = T.WALL; grid[3][25] = T.WALL;
    grid[4][2] = T.WALL; grid[4][5] = T.WALL;
    grid[4][7] = T.WALL; grid[4][20] = T.WALL; grid[4][22] = T.WALL; grid[4][25] = T.WALL;
    for(let x=2; x<=5; x++) grid[6][x] = T.WALL;
    for(let x=7; x<=20; x++) grid[6][x] = T.WALL;
    for(let x=22; x<=25; x++) grid[6][x] = T.WALL;
    grid[7][2] = T.WALL; grid[7][5] = T.WALL;
    grid[7][7] = T.WALL; grid[7][20] = T.WALL;
    grid[7][22] = T.WALL; grid[7][25] = T.WALL;
    for(let y=9; y<=13; y++){ grid[y][7] = T.WALL; grid[y][20] = T.WALL; }
    for(let x=10; x<=11; x++) grid[9][x] = T.WALL;
    for(let x=16; x<=17; x++) grid[9][x] = T.WALL;
    for(let x=2; x<=5; x++){ grid[9][x] = T.WALL; grid[12][x] = T.WALL; }
    for(let x=22; x<=25; x++){ grid[9][x] = T.WALL; grid[12][x] = T.WALL; }
    const hx0 = 10, hx1 = 17, hy0 = 14, hy1 = 17;
    for(let y=hy0; y<=hy1; y++){
      for(let x=hx0; x<=hx1; x++){
        if(y===hy0 || y===hy1 || x===hx0 || x===hx1) grid[y][x] = T.WALL;
        else grid[y][x] = T.HOUSE;
      }
    }
    grid[hy0][13] = T.GATE; grid[hy0][14] = T.GATE;
    for(let y=2; y<=12; y++){
      const mirrorY = ROWS - 1 - y;
      for(let x=1; x<COLS-1; x++){
        if(grid[y][x] === T.WALL) grid[mirrorY][x] = T.WALL;
      }
    }
    for(let x=10; x<=11; x++) grid[21][x] = T.WALL;
    for(let x=16; x<=17; x++) grid[21][x] = T.WALL;
    for(let y=1; y<ROWS-1; y++){
      for(let x=1; x<COLS-1; x++){
        if(grid[y][x] === T.EMPTY){
          if(x >= 9 && x <= 18 && y >= 13 && y <= 18) continue;
          grid[y][x] = T.PELLET;
        }
      }
    }
    grid[3][1] = T.POWER; grid[3][26] = T.POWER; grid[27][1] = T.POWER; grid[27][26] = T.POWER;
    for(let x=1; x<9; x++) grid[15][x] = T.PELLET;
    for(let x=19; x<COLS-1; x++) grid[15][x] = T.PELLET;
  }
  carve();

  function countPellets(){
    let c=0;
    for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
      if(grid[y][x]===T.PELLET || grid[y][x]===T.POWER) c++;
    }
    return c;
  }
  pelletsLeft = countPellets();

  class Entity{
    constructor(x, y, speed, isGhost = false){
      this.gridX = x;
      this.gridY = y;
      this.pixelX = x * tile + tile/2;
      this.pixelY = y * tile + tile/2;
      this.direction = DIR.LEFT;
      this.nextDirection = DIR.LEFT;
      this.speed = speed;
      this.isGhost = isGhost;
      this.released = true;
      this.releaseAt = 0;
      this.state = 'normal';
      this.targetX = x;
      this.targetY = y;
      this.moving = false;
      this.stuckCounter = 0;
    }
    isAtTileCenter(){
      const centerX = this.gridX * tile + tile/2;
      const centerY = this.gridY * tile + tile/2;
      return Math.abs(this.pixelX - centerX) < 2 && Math.abs(this.pixelY - centerY) < 2;
    }
    canMoveTo(dir){
      let nextX = this.gridX + dir.x;
      let nextY = this.gridY + dir.y;
      if(nextX < 0 && this.gridY === midY) nextX = COLS - 1;
      if(nextX >= COLS && this.gridY === midY) nextX = 0;
      if(nextY < 0 || nextY >= ROWS) return false;
      if(nextX < 0 || nextX >= COLS) return false;
      const tileHere = tileAt(nextX, nextY);
      if(tileHere === T.GATE){
        if(tileAt(this.gridX, this.gridY) === T.HOUSE && dir === DIR.UP) return true;
        if(this.isGhost && this.state === 'eaten' && dir === DIR.DOWN) return true;
        return false;
      }
      return tileHere !== T.WALL;
    }
    update(){
      if(!this.moving){
        this.stuckCounter++;
        if(this.stuckCounter > 10 && this.isGhost){
          const validDirs = DIRS_ORDER.filter(dir => this.canMoveTo(dir));
          if(validDirs.length > 0){
            this.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
            this.nextDirection = this.direction;
            this.stuckCounter = 0;
          }
        }
      } else {
        this.stuckCounter = 0;
      }
      if(!this.moving){
        if(this.isAtTileCenter() && !sameDir(this.direction, this.nextDirection)){
          if(this.canMoveTo(this.nextDirection)){
            this.direction = this.nextDirection;
            this.targetX = this.gridX + this.direction.x;
            this.targetY = this.gridY + this.direction.y;
            if(this.targetX < 0 && this.gridY === midY) this.targetX = COLS - 1;
            if(this.targetX >= COLS && this.gridY === midY) this.targetX = 0;
            this.moving = true;
          }
        }
        if(!this.moving && this.canMoveTo(this.direction)){
          this.targetX = this.gridX + this.direction.x;
          this.targetY = this.gridY + this.direction.y;
          if(this.targetX < 0 && this.gridY === midY) this.targetX = COLS - 1;
          if(this.targetX >= COLS && this.gridY === midY) this.targetX = 0;
          this.moving = true;
        }
      }
      if(this.moving){
        const targetPixelX = this.targetX * tile + tile/2;
        const targetPixelY = this.targetY * tile + tile/2;
        let speed = this.speed;
        if(this.isGhost){
          if(this.state === 'frightened') speed *= 0.5;
          else if(this.state === 'eaten') speed *= 2.0;
          if(this.gridY === midY && (this.gridX < 3 || this.gridX > COLS-4)) speed *= 0.4;
        }
        const dx = targetPixelX - this.pixelX;
        const dy = targetPixelY - this.pixelY;
        const distance = Math.hypot(dx, dy);
        if(distance <= speed){
          this.pixelX = targetPixelX;
          this.pixelY = targetPixelY;
          this.gridX = this.targetX;
          this.gridY = this.targetY;
          this.moving = false;
          if(this === player) this.onArriveTile();
        } else {
          this.pixelX += (dx / distance) * speed;
          this.pixelY += (dy / distance) * speed;
        }
      }
    }
    onArriveTile(){
      const t = tileAt(this.gridX, this.gridY);
      if(t === T.PELLET){ 
        grid[this.gridY][this.gridX] = T.EMPTY; 
        score += 10; 
        pelletsLeft--; 
        bumpHUD(); 
      }
      else if(t === T.POWER){
        grid[this.gridY][this.gridX] = T.EMPTY; 
        score += 50; 
        pelletsLeft--; 
        frightened = FRIGHT_TIME_BASE; 
        bumpHUD();
        ghosts.forEach(g => {
          if(g.released && g.state === 'normal'){
            g.state = 'frightened';
            g.direction = {x: -g.direction.x, y: -g.direction.y};
            g.nextDirection = g.direction;
            g.moving = false;
          }
        });
      }
      if(pelletsLeft <= 0){
        level++; 
        document.getElementById('level').textContent = level; 
        frightened = 0;
        player.speed += 0.3;
        ghosts.forEach(g => g.speed += 0.25);
        for(let y = 0; y < ROWS; y++){
          for(let x = 0; x < COLS; x++){
            if(grid[y][x] === T.EMPTY) grid[y][x] = T.PELLET;
          }
        }
        grid[1][1] = T.POWER; 
        grid[1][COLS-2] = T.POWER; 
        grid[ROWS-2][1] = T.POWER; 
        grid[ROWS-2][COLS-2] = T.POWER;
        pelletsLeft = countPellets();
        resetPositions(true);
      }
    }
  }

  function tileAt(x, y){ 
    if(y < 0 || y >= ROWS || x < 0 || x >= COLS) return T.WALL; 
    return grid[y][x]; 
  }

  const playerStart = {x: midX, y: midY + 5};
  const player = new Entity(playerStart.x, playerStart.y, 2.5);

  const ghosts = [
    new Entity(midX - 2, midY, 2.3, true),
    new Entity(midX + 2, midY, 2.2, true),
    new Entity(midX - 1, midY + 1, 2.1, true),
    new Entity(midX + 1, midY + 1, 2.0, true),
  ];
  const ghostColors = ["#ff3b5b","#ff79c6","#4de2ff","#ffb86c"];

  const RELEASE = [0.6, 2.5, 4.8, 7.2];
  let timeSinceStart = 0;

  const MODES = [
    {m:'scatter', t:7},
    {m:'chase', t:20},
    {m:'scatter', t:7},
    {m:'chase', t:20},
    {m:'scatter', t:5},
    {m:'chase', t:9999}
  ];
  let modeIndex = 0;
  let modeTimer = 0;
  const currentMode = () => MODES[Math.min(modeIndex, MODES.length-1)].m;

  let frightened = 0;
  const FRIGHT_TIME_BASE = 6;

  function entitiesCollide(a, b){ return a.gridX === b.gridX && a.gridY === b.gridY; }

  function eatGhost(g){
    score += 200; 
    bumpHUD();
    g.state = 'eaten';
    g.targetX = midX;
    g.targetY = midY + 1;
    g.gridX = midX;
    g.gridY = midY + 1;
    g.pixelX = midX * tile + tile/2;
    g.pixelY = (midY + 1) * tile + tile/2;
    g.direction = DIR.UP;
    g.nextDirection = DIR.UP;
    g.released = false;
    g.releaseAt = timeSinceStart + 3.0;
    g.moving = false;
  }

  function resetPositions(keepScore){
    if(!keepScore){
      score = 0; 
      level = 1; 
      player.speed = 2.5;
      ghosts[0].speed = 2.3; 
      ghosts[1].speed = 2.2; 
      ghosts[2].speed = 2.1; 
      ghosts[3].speed = 2.0;
      modeIndex = 0; 
      modeTimer = 0;
    }
    player.gridX = playerStart.x; 
    player.gridY = playerStart.y; 
    player.pixelX = playerStart.x * tile + tile/2;
    player.pixelY = playerStart.y * tile + tile/2;
    player.direction = DIR.LEFT; 
    player.nextDirection = DIR.LEFT;
    player.moving = false;
    player.stuckCounter = 0;

    const ghostStarts = [
      {x: midX-2, y: midY},
      {x: midX+2, y: midY}, 
      {x: midX-1, y: midY+1},
      {x: midX+1, y: midY+1}
    ];
    const ghostDirs = [DIR.LEFT, DIR.RIGHT, DIR.UP, DIR.UP];

    ghosts.forEach((g, i) => {
      g.gridX = ghostStarts[i].x;
      g.gridY = ghostStarts[i].y;
      g.pixelX = ghostStarts[i].x * tile + tile/2;
      g.pixelY = ghostStarts[i].y * tile + tile/2;
      g.direction = ghostDirs[i];
      g.nextDirection = ghostDirs[i];
      g.released = false;
      g.releaseAt = RELEASE[i];
      g.state = 'normal';
      g.moving = false;
      g.stuckCounter = 0;
    });
    frightened = 0; 
    timeSinceStart = 0;
    drawLives();
  }

  const corners = [
    {x: COLS-2, y: 1},
    {x: 1, y: 1},
    {x: COLS-2, y: ROWS-2},
    {x: 1, y: ROWS-2}
  ];

  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
  function dist2(ax, ay, bx, by){ const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }

  function ghostChaseTarget(gi){
    const blinky = ghosts[0];
    if(gi === 0) return {x: player.gridX, y: player.gridY};
    if(gi === 1){
      const tx = clamp(player.gridX + player.direction.x * 4, 0, COLS-1);
      const ty = clamp(player.gridY + player.direction.y * 4, 0, ROWS-1);
      return {x: tx, y: ty};
    }
    if(gi === 2){
      const px2 = clamp(player.gridX + player.direction.x * 2, 0, COLS-1);
      const py2 = clamp(player.gridY + player.direction.y * 2, 0, ROWS-1);
      const vx = px2 - blinky.gridX, vy = py2 - blinky.gridY;
      const tx = clamp(px2 + vx, 0, COLS-1);
      const ty = clamp(py2 + vy, 0, ROWS-1);
      return {x: tx, y: ty};
    }
    const d2 = dist2(player.gridX, player.gridY, ghosts[3].gridX, ghosts[3].gridY);
    if(d2 <= 64) return {...corners[3]};
    return {x: player.gridX, y: player.gridY};
  }
  const ghostScatterTarget = gi => ({...corners[gi]});

  function chooseNextDirection(g, gi){
    if(g.state === 'eaten'){
      const target = {x: midX, y: midY + 1};
      return findBestDirection(g, target);
    }
    if(g.state === 'frightened'){
      const validDirs = DIRS_ORDER.filter(dir => !isOpposite(dir, g.direction) && g.canMoveTo(dir));
      if(validDirs.length === 0){
        const allValid = DIRS_ORDER.filter(dir => g.canMoveTo(dir));
        return allValid.length > 0 ? allValid[0] : g.direction;
      }
      return validDirs[Math.floor(Math.random() * validDirs.length)];
    }
    const target = (currentMode() === 'scatter') ? ghostScatterTarget(gi) : ghostChaseTarget(gi);
    return findBestDirection(g, target);
  }

  function findBestDirection(g, target){
    const reverse = {x: -g.direction.x, y: -g.direction.y};
    let bestDir = g.direction;
    let bestDist = Infinity;
    const validDirs = DIRS_ORDER.filter(dir => !sameDir(dir, reverse) && g.canMoveTo(dir));
    if(validDirs.length === 0){
      const reverseDirs = DIRS_ORDER.filter(dir => g.canMoveTo(dir));
      if(reverseDirs.length > 0) return reverseDirs[0];
      return g.direction;
    }
    for(const dir of validDirs){
      const nextX = g.gridX + dir.x;
      const nextY = g.gridY + dir.y;
      const dist = dist2(nextX, nextY, target.x, target.y);
      if(dist < bestDist){ bestDist = dist; bestDir = dir; }
    }
    return bestDir;
  }

  function drawBoard(){
    ctx.fillStyle = "#06101d"; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for(let y = 0; y < ROWS; y++){
      for(let x = 0; x < COLS; x++){
        const t = grid[y][x], px = x * tile, py = y * tile;
        if(t === T.WALL){
          ctx.fillStyle = getVar('--wall'); 
          ctx.fillRect(px, py, tile, tile);
          ctx.strokeStyle = getVar('--wall-edge'); 
          ctx.lineWidth = Math.max(2, tile*0.08); 
          ctx.strokeRect(px+2, py+2, tile-4, tile-4);
        } else {
          ctx.fillStyle = getVar('--floor'); 
          ctx.fillRect(px, py, tile, tile);
          if(t === T.PELLET){
            ctx.fillStyle = "#f3f6ff"; 
            ctx.beginPath(); 
            ctx.arc(px + tile/2, py + tile/2, Math.max(1.5, tile*0.08), 0, Math.PI*2); 
            ctx.fill();
          }
          if(t === T.POWER){
            ctx.fillStyle = getVar('--gold'); 
            ctx.beginPath(); 
            ctx.arc(px + tile/2, py + tile/2, Math.max(3, tile*0.18), 0, Math.PI*2); 
            ctx.fill();
            ctx.shadowColor = getVar('--gold'); 
            ctx.shadowBlur = 14; 
            ctx.fill(); 
            ctx.shadowBlur = 0;
          }
          if(t === T.GATE){ 
            ctx.fillStyle = getVar('--gate'); 
            ctx.fillRect(px, py + tile*0.4, tile, tile*0.2); 
          }
        }
      }
    }
  }
  const getVar = name => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

  function drawPeacock(cx, cy, size, dir, tick){
    const s = size/16, swing = Math.sin(tick*8)*1.2;
    ctx.save(); 
    ctx.translate(cx, cy);
    if (dir === DIR.LEFT) ctx.scale(-1, 1);
    let rot = 0; 
    if(dir === DIR.RIGHT) rot = 0.05; 
    if(dir === DIR.UP) rot = -0.1; 
    if(dir === DIR.DOWN) rot = 0.1;
    ctx.rotate(rot);
    for(let i = 0; i < 7; i++){
      const a = (-Math.PI/2) + (i-3)*0.18 + swing*0.02, r = 8*s;
      const tx = Math.cos(a)*r, ty = Math.sin(a)*r;
      ctx.fillStyle = i%2 ? "#2de2ff" : "#38f2c6"; 
      ctx.beginPath(); 
      ctx.arc(tx, ty, 3.0*s, 0, Math.PI*2); 
      ctx.fill();
      ctx.fillStyle = "#0a1020"; 
      ctx.beginPath(); 
      ctx.arc(tx, ty, 1.5*s, 0, Math.PI*2); 
      ctx.fill();
      ctx.fillStyle = "#7fffd4"; 
      ctx.beginPath(); 
      ctx.arc(tx, ty, 0.85*s, 0, Math.PI*2); 
      ctx.fill();
    }
    ctx.rotate(-rot);
    ctx.fillStyle = "#07c3ff"; 
    ctx.beginPath(); 
    ctx.ellipse(0, 0, 5.2*s, 6.2*s, 0, 0, Math.PI*2); 
    ctx.fill();
    ctx.fillStyle = "#49e1ff"; 
    ctx.globalAlpha = .6; 
    ctx.beginPath(); 
    ctx.ellipse(-1*s, 1*s, 3.3*s, 3.0*s, 0, 0, Math.PI*2); 
    ctx.fill(); 
    ctx.globalAlpha = 1;
    const hx = dir.x*1.4*s, hy = dir.y*1.4*s;
    ctx.fillStyle = "#07c3ff"; 
    ctx.beginPath(); 
    ctx.ellipse(5*s+hx, -2*s+hy, 3.2*s, 3.1*s, 0, 0, Math.PI*2); 
    ctx.fill();
    ctx.fillStyle = getVar('--gold'); 
    ctx.beginPath(); 
    ctx.moveTo(8.2*s+hx, -2*s+hy); 
    ctx.lineTo(10.6*s+hx, -1.2*s+hy); 
    ctx.lineTo(8.2*s+hx, -0.2*s+hy); 
    ctx.closePath(); 
    ctx.fill();
    ctx.fillStyle = "#0b0f14"; 
    ctx.beginPath(); 
    ctx.arc(6.6*s+hx, -2.1*s+hy, 0.9*s, 0, Math.PI*2); 
    ctx.fill();
    ctx.fillStyle = "#fff"; 
    ctx.beginPath(); 
    ctx.arc(6.9*s+hx, -2.4*s+hy, 0.4*s, 0, Math.PI*2); 
    ctx.fill();
    for(let i = 0; i < 3; i++){ 
      ctx.strokeStyle = "#2de2ff"; 
      ctx.lineWidth = 1.1*s; 
      ctx.beginPath(); 
      ctx.moveTo(5.2*s+hx, -4.6*s+hy); 
      ctx.lineTo(5.2*s+hx+(i-1)*1.1*s, -6.6*s+hy); 
      ctx.stroke(); 
      ctx.fillStyle = "#2de2ff"; 
      ctx.beginPath(); 
      ctx.arc(5.2*s+hx+(i-1)*1.1*s, -7.2*s+hy, .75*s, 0, Math.PI*2); 
      ctx.fill(); 
    }
    ctx.restore();
  }

  function drawGhost(g, color, tick){
    const x = g.pixelX, y = g.pixelY, r = tile*0.34;
    ctx.save(); 
    ctx.translate(x, y);
    if(g.state === 'frightened'){
      ctx.fillStyle = "#3f65ff";
      if(frightened < 2 && Math.floor(tick*10)%2 === 0){ ctx.fillStyle = "#fff"; }
    } else if(g.state === 'eaten'){
      ctx.fillStyle = "rgba(255,255,255,0.3)";
    } else {
      ctx.fillStyle = color;
    }
    ctx.beginPath(); 
    ctx.moveTo(-r, 0); 
    ctx.arc(0, 0, r, Math.PI, 0); 
    ctx.lineTo(r, r*0.9);
    for(let i = 4; i > 0; i--){ 
      const px = -r + (i*(2*r)/5); 
      ctx.quadraticCurveTo(px, r*1.2, px - r/5, r*0.9); 
    }
    ctx.closePath(); 
    ctx.fill();
    const eyeOff = (g.state === 'frightened') ? 0 : Math.sign(g.direction.x || g.direction.y)*3;
    ctx.fillStyle = "#fff";
    for(const ex of [-r*0.35, r*0.2]){ 
      ctx.beginPath(); 
      ctx.ellipse(ex, -r*0.2, r*0.23, r*0.28, 0, 0, Math.PI*2); 
      ctx.fill(); 
      ctx.fillStyle = "#0b0f14"; 
      ctx.beginPath(); 
      ctx.arc(ex + eyeOff*0.2, -r*0.2 + eyeOff*0.1, r*0.12, 0, Math.PI*2); 
      ctx.fill(); 
      ctx.fillStyle = "#fff"; 
    }
    ctx.restore();
  }

  function drawLives(){
    const el = document.getElementById('lives'); 
    el.innerHTML = "";
    for(let i = 0; i < lives; i++){ 
      const d = document.createElement('div'); 
      d.className = "life"; 
      el.appendChild(d); 
    }
  }
  function bumpHUD(){
    document.getElementById('score').textContent = score;
    hi = Math.max(hi, score); 
    document.getElementById('hi').textContent = hi;
  }
  let lives = 3; 
  bumpHUD(); 
  drawLives();

  // Ajuste total do tamanho, evitando escala dupla e realinhando entidades
  function fit(){
    const aspect = COLS / ROWS;

    const viewportH = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;

    const headerH = document.querySelector('header')?.offsetHeight || 0;
    const hudH = document.querySelector('.hud')?.offsetHeight || 0;
    const wrapPad = 24;
    const reserved = headerH + hudH + wrapPad;

    const maxW = shell.clientWidth;
    const maxH = Math.max(220, viewportH - reserved);

    let targetW = Math.min(maxW, maxH * aspect);
    let targetH = targetW / aspect;

    if (targetH < maxH && (maxW / aspect) <= maxH) {
      targetW = maxW;
      targetH = targetW / aspect;
    }

    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    canvas.width  = Math.round(targetW * dpr);
    canvas.height = Math.round(targetH * dpr);
    canvas.style.width  = targetW + 'px';
    canvas.style.height = targetH + 'px';

    tile = Math.floor(canvas.width / COLS); // usa pixels f√≠sicos

    shell.style.height = targetH + 'px';

    // Reposiciona entidades no novo grid sem alterar o estado l√≥gico
    if (player){
      player.pixelX = player.gridX * tile + tile/2;
      player.pixelY = player.gridY * tile + tile/2;
    }
    if (ghosts && ghosts.length){
      for (const g of ghosts){
        g.pixelX = g.gridX * tile + tile/2;
        g.pixelY = g.gridY * tile + tile/2;
      }
    }
  }

  window.addEventListener('resize', fit, {passive: true});
  if (window.visualViewport){
    window.visualViewport.addEventListener('resize', fit, {passive:true});
  }
  window.addEventListener('orientationchange', fit, {passive:true});
  new ResizeObserver(()=>fit()).observe(shell);
  window.addEventListener('load', fit, {passive:true});
  fit();

  /* Controles */
  function startGame(){
    if(!running){
      running = true; 
      last = performance.now(); 
      document.getElementById('overlay').style.display = 'none'; 
      resetPositions(true);
    }
  }
  document.getElementById('overlay').addEventListener('click', startGame, {passive:true});
  canvas.addEventListener('click', ()=>{ if(!running) startGame(); }, {passive:true});

  window.addEventListener('keydown', e => {
    if(e.code === "Space"){ startGame(); return; }
    const map = {
      ArrowLeft: DIR.LEFT, KeyA: DIR.LEFT,
      ArrowRight: DIR.RIGHT, KeyD: DIR.RIGHT,
      ArrowUp: DIR.UP, KeyW: DIR.UP,
      ArrowDown: DIR.DOWN, KeyS: DIR.DOWN
    };
    if(map[e.code]){ 
      e.preventDefault(); 
      player.nextDirection = map[e.code]; 
    }
  }, {passive: false});

  const touch = document.getElementById('touch');
  const dirMap = { up:DIR.UP, down:DIR.DOWN, left:DIR.LEFT, right:DIR.RIGHT };
  ["up","down","left","right"].forEach(k=>{
    const btn = touch.querySelector("."+k);
    const handler = (e)=>{ e.preventDefault(); player.nextDirection = dirMap[k]; };
    btn.addEventListener('pointerdown', handler, {passive:false});
    btn.addEventListener('touchstart', handler, {passive:false});
    btn.addEventListener('click', handler, {passive:false});
  });

  let last = performance.now();

  function update(dt){
    timeSinceStart += dt;
    if(frightened <= 0){
      modeTimer += dt;
      const cur = MODES[Math.min(modeIndex, MODES.length-1)];
      if(modeTimer >= cur.t){ 
        modeIndex = Math.min(modeIndex + 1, MODES.length-1); 
        modeTimer = 0; 
        ghosts.forEach(g => {
          if(g.released && g.state === 'normal'){
            g.direction = {x: -g.direction.x, y: -g.direction.y};
            g.nextDirection = g.direction;
            g.moving = false;
          }
        });
      }
    } else {
      frightened -= dt; 
      if(frightened <= 0) {
        frightened = 0;
        ghosts.forEach(g => { if(g.state === 'frightened') g.state = 'normal'; });
      }
    }
    player.update();
    for(let i = 0; i < ghosts.length; i++){
      const g = ghosts[i];
      const here = tileAt(g.gridX, g.gridY);
      if(!g.released){
        if(timeSinceStart >= g.releaseAt && g.state !== 'eaten'){
          if(here === T.HOUSE){
            if(g.gridX < midX) g.nextDirection = DIR.RIGHT;
            else if(g.gridX > midX) g.nextDirection = DIR.LEFT;
            else g.nextDirection = DIR.UP;
          } else if(here === T.GATE){
            g.nextDirection = DIR.UP;
          } else {
            g.released = true;
            g.direction = (i === 0 || i === 2) ? DIR.LEFT : DIR.RIGHT;
            g.nextDirection = g.direction;
          }
        } else if(g.state !== 'eaten'){
          if(here === T.HOUSE && g.isAtTileCenter() && Math.random() < 0.1){
            const dirs = [DIR.LEFT, DIR.RIGHT, DIR.UP, DIR.DOWN].filter(d => g.canMoveTo(d));
            if(dirs.length > 0) g.nextDirection = dirs[Math.floor(Math.random() * dirs.length)];
          }
        }
      } else {
        if(g.isAtTileCenter() && !g.moving) g.nextDirection = chooseNextDirection(g, i);
      }
      if(g.state === 'eaten' && g.gridX === midX && g.gridY === midY + 1){
        g.state = 'normal';
        g.released = false;
        g.releaseAt = timeSinceStart + 2.0;
      }
      g.update();
    }
    for(const g of ghosts){
      if(entitiesCollide(player, g)){
        if(g.state === 'frightened'){
          eatGhost(g);
        } else if(g.state === 'normal'){
          lives--;
          drawLives();
          if(lives <= 0){
            running = false; 
            const ov = document.getElementById('overlay');
            ov.style.display = 'flex';
            ov.querySelector('.title').textContent = "Game over - tap or press Space to play again";
            score = 0; 
            bumpHUD();
          } else {
            resetPositions(true);
          }
          break;
        }
      }
    }
  }

  function render(tick){
    // Sem ctx.scale(dpr,dpr). Desenho j√° em pixels f√≠sicos do canvas
    drawBoard();
    ghosts.forEach((g, i) => drawGhost(g, ghostColors[i], tick));
    drawPeacock(player.pixelX, player.pixelY, tile*0.85, player.direction, tick);
  }

  function loop(now){
    if(!running){ requestAnimationFrame(loop); return; }
    const dt = Math.min(0.025, (now - last)/1000);
    last = now;
    update(dt); 
    render(now/1000); 
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  document.getElementById('overlay').style.display = 'flex';
  resetPositions(true);
})();
</script>
</body>
</html>

